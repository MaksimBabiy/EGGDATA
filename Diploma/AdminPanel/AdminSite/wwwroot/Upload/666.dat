
_____________________________________________________________________________________________________________________________________
********СТАТИЧЕСКИЕ КЛАССЫ********

Статический класс - это контейнер, который содержит в себе только статические члены.
Правила статических классов:
1. Экземпляр статического класса нельзя создать.
2. Статический класс наследуется только от Object.
3. Не реализует интерфейсы.
4. Не может содержать конструкторов экземпляров.
5. Статический класс закрыт для наследования от него.
6. Статические классы могут содержать только статические члены.

Доступ к членам статического класса осуществляется на Классе-Обьекте.

Статическая переменная - это общая переменная для всех экземляров класса, которая хранится в обьекте.
Статическими могут быть методы и свойства. Статические методы не могут обращатсья к нестатическим полям.

Статические конструкторы обладают следующими свойствами:
	1. Статический конструктор не имеет модификаторо доступа и не принимает параметров.
	2. Статический конструктор вызывается автоматически для инициализации класса перед созданием первого экземляра
		или ссылкой на какие-либо статические члены.
	3. Статический конструктор нельзя вызвать напрямую.
	4. Пользователь не управляет тем, когда статический конструктор выполняется в программе.
	5. Типичным использованием статических конструкторо является случай, когда класс использует файл журнала и
		конструктор применяется для добавления записей в этот файл.

Единственное назначение статических конструкторов - присваивать исходные значения статическими перенным.

Статические методы могут быть перегруженны.

Статические поля readonly должны быть инициализированы  в конструкторе.

Статические члены не могут быть виртуальными, переопределенными и абстрактыми.
Статические члены поддерживают замещение.

Методы расширения позволяют "добавлять" методы в существующие типы без создания новго производного типа, перекомпиляции или иного изменения исходного типа. Они могут быть только статическими и создаваться только в статических классах. Аргумент расширения всегда должен быть только один (+ ключевое слово this) и стоять первым в списке аргументов.

Расширяющие методы вызываются на экземпляре класса.

Расширяющие методы не могут иметь опциональных параметров, но могут быть перегруженны, аргументы не могут быть out/ref.
_____________________________________________________________________________________________________________________________________
********НАСЛЕДОВАНИЕ********

Наследование - механизм языка, позволяющий написать класс, на основе уже существующего.

Модификаторы доступа - ключевые слова, задающие доступность члена или типа. При их помощи, можно задавать
уровни доступа к членам.

Ключевое слова base используется для обращения к базовому классу (base.Method() или base() в наследовании конструктора).

Ключевое слово sealed - запрещает наследование от типа(класса, метода).
Указание ключевого слова sealed в методах или свойствах запрещает дальнейшее переопределение (в связке с override).
_____________________________________________________________________________________________________________________________________
********ПОЛИМОРФИЗМ********

Полиморфизм - возможность обьектов с одинаковой спецификацией иметь различную реализацию.
Формы полиморфизма:
	1. Ad-hoc полиморфизм
	2. Классический (принудительный) полиморфизм:
		*использование виртуальных членов (переопределение virtual/override).
		*приведение типов
			Приведение к базовому типу используется для сокрытия реализации членов производного класса.
			Upcast - приведение экземпляра производного класса к базовому типу.
			Downcast - приведение экземпляра базового типа к производному типу.
			Downcast невозможен без предварительного Upcast.

	В случае одновременного использования двух форм классического полиморфизма,
	нейтрализует вторую (доминирует над второй). Но их можно комбинировать.

Оператор is проверяет совместимость обьекста с заданным типом.
	Если предоставленный обьект может быть приведен к предоставленному типу не вызывая исключение,
	выражение is принимает значение true.

Оператор as используется для выполнения преобразований между совместимыми ссылочными типами.
Оператор as подобен оператору приведения (безопасное Приведение). Однако, если преобразование невозможно, 
as возвращает значение null, а не вызывает исключение.

_____________________________________________________________________________________________________________________________________
********АБСТРАКЦИЯ********

Абстракция - придание обьекту характеристик, которые отличают его от всех других обьектов, 
четко определяя его концептуальные границы.

Абстрагирование - способ выделить набор значимых характеристик обьекта, исключая из рассмотрения незначимые.
Соответственно, абстракция - это набор всех таких характеристик.

abstract = классы, методы, свойства, индексаторы, события.

Абстрактный класс - это базовый класс, который не предпологает создания экземпляров через вызов конструктора напрямую,
но экземпляр абстрактного класса создается неявно при построении экземпляра производного конкретного класса.
Абстрактные классы могут сдержать как абстрактные, так и не абстрактные члены. Класс, производный от абстрактного 
должен содержать фактические реализации всех наслежуемых абстрактных членов.

Абстрактный метод - является неявным виртуальным методом, создание абстрактных методов допускается только в абстрактных
классах, тело метода отсутствует, реализуется с помощью ключевого слова override.
_____________________________________________________________________________________________________________________________________
********ИНТЕРФЕЙСЫ********

Интерфейс - семантическая и синтаксическая конструкция в коде программы, используемая для специфицирования услуг, предоставляемых классом или компонентом.
Интерфейс - стереотип, являющийся аналогом чистого абстрактного класса, в котором запрещена любая реализация.

Имя интерфейса начинается с буквы I.

Правила использования:
	1. Невозможно создать экземпляр интерфейса.
	2. Интерфейсы и члены интерфейсов являются абстрактными. Интерфесы не имеют реализации.
	3. Интерфейс может содержать только абстрактные члены (методы, свойства, события или иднексаторы).
	4. Членый интерфейсов автоматически являются открытыми, абстрактными, и они не могут иметь модификаторов доступа.
	5. Интерфейсы не могут содержать константы, поля, операторы, конструкторы экземпляров, деструкторы или вложенные типы.
	6. Класс и структуры, которые реализуют интерфейс, должны реализовать члены этого интерфейса, указанные при его создании.

Преимущества использования:
	1. Класс или структура может реализовать несколько интерфейсов.
	2. Если класс или структура реализует интерфейс, она получает только имена и сигнатуры метода.
	3. Интерфейсы определяют поведение экземпляров производных классов.
	4. Базовый класс может обладать ненужным функционалом, полученным от других его базовых классов,
		чего можно избежать используя интерфейсы.
_____________________________________________________________________________________________________________________________________
********МАССИВЫ********

Массивы в C# ковариантные, но не контрвариантные.

Ковариантность - это неявный Upcast всех элементов массива.
Контрвариантность - это неявный Downcast всех элементов массива.

Массивы элементов ссылочных типов ковариантные но, не контрвариантные.
Массивы элементов структурных типов не ковариантные и не контрвариантные.
_____________________________________________________________________________________________________________________________________
********ИНДЕКСАТОРЫ********

public int this[int index]
{
	get { return array[index]; }
	set { array[index] = value; }
}

Индексаторы позволяют индексировать экземпляры класса или структуры так же, как массивы. Индексаторы напоминают свойства,
но их методы доступа принимают параметры.

Индексаторы не обязаны использовать в качестве индекса целочисленное значение, конкретный механизм поиска определяет программист.
Индексаторы можно перегружать.
Индексаторы могут иметь более одного формального параметра, например, при доступе к двуъмерному массиву.
_____________________________________________________________________________________________________________________________________
********СТРУКТУРЫ********

Структура - это конструукция языка, позволяющая содержать в себе набор полей различных типов.
В структурах нельзя инициализировать поля непосредственно в месте создания. Инициализация статических полей необязательна.

Структуры хранятся в стеке и обычно используются для инкапсуляции небольших групп связанных переменных.
Структуры могут содержать конструкторы, константы, поля, методы, свойства, индексаторы, операторы, события и вложенные типы, однако, если требуются несколько таких членов, рекомендуется использовать классы.

Создание экземпляра не требует вызова конструктора.
Если в структуре имеются члены, которые обращаются к полю и нет пользовательского конструктора, то требуется при создании экземпляра
вызывать конструктор по умолчанию.
Если в структуре имеется пользовательский конструктор, то требуется в нем инициализировать все поля.
Конструктор по умолчанию нельзя создавать явно.
Структуры могут содержать статические члены.
Статические структуры недопустимы.
В структурах можно создавать автоматически реализуемые свойства, при этом требуется использовать конструктор при построении экземпляра.

Структуры могут реализовывать интерфейсы, но они не могут наследоваться от структур или классов, поскольку уже наследуются не явно от абстрактного класса ValueType.
От структур наследоваться запрещено.

Стек - это специальная область в памяти, в которой хранятся структурные типы.
_____________________________________________________________________________________________________________________________________






 